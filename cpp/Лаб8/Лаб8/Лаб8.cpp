// Лаб8.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//
/*
Вариант №8.

Из произвольного текста, содержащего не более 10 строк, в каждой строке не
более 80 символов, вывести на экран слова в порядке не возрастания их
длины.



проведём размышления:

всего символов < 10 * 80; минимлаьное число слов = 10, максимальное по 1 букве через пробел будет 10 * 80 / 2 = 10 * 40 = 400





*/
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <locale.h>
#include <conio.h>

int main() {
    const int M = 10;
    char* s[M], wstr[80];
    char** words = new char* [40];
    int kol_str = 0;

    setlocale(0, "");
    system("cls");

    // Ввод строк
    while (kol_str < M && gets_s(wstr, 80) != NULL) {
        s[kol_str] = new char[strlen(wstr) + 1];
        strcpy_s(s[kol_str], strlen(wstr) + 1, wstr);
        kol_str++;
    }

    // Разделение на слова
    int e = 0;
    bool inword = false;
    for (int i = 0; i < kol_str; i++) {
        int len = strlen(s[i]);
        int word_start = 0;

        for (int j = 0; j <= len; j++) {
            if (s[i][j] == ' ' || s[i][j] == ',' || s[i][j] == '\0') {
                if (inword) {
                    int word_len = j - word_start;
                    words[e] = new char[word_len + 1];
                    strncpy_s(words[e], word_len + 1, s[i] + word_start, word_len);
                    words[e][word_len] = '\0'; // Обязательно добавляем терминатор!
                    e++;
                    inword = false;
                }
            }
            else {
                if (!inword) {
                    word_start = j;
                    inword = true;
                }
            }
        }
    }

   //вывод слов по длинне

    //std::sort(words, words + e, [](const char* a, const char* b) {
    //    return std::strlen(a) < std::strlen(b);
    //    });

    //for (int i = 0; i < e; i++) {
    //    std::cout << words[i] << "\n";
    //}


    for (int l = 1; l <= 80; ++l) {  // Начинаем с длины 1
        for (int i = 0; i < e; ++i) {
            if (std::strlen(words[i]) == l) {
                std::cout << words[i] << '\n';
            }
        }
    }


    // Освобождение памяти
    for (int i = 0; i < kol_str; i++) {
        delete[] s[i];
    }

    for (int i = 0; i < e; i++) {
        delete[] words[i];
    }
    delete[] words;

    return 0;
}





//#include <iostream>
//#include <conio.h>
////#include <string.h>
//#include <stdlib.h>
//#include <locale.h>
//
//
//int main()
//{
//    const int M = 10; // M - максимальное количество строк
//    char* s[M], word[80], // массив указателей на строки 
//        wstr[80]; // рабочая строка
//
//    char** words = new char* [40];
//    char buffer[100];
//    int i, // текущий индекс строки
//        j, // текущий индекс символа в строке
//        j1,
//        e,
//        f,
//        k,
//        dl_wstr, //// длина текущей вводимой строки
//        kol_str, // количество введенных строк
//        // местоположение: если находимся внутри слова, то inword=1, а если вне слова, то inword=0
//        inword = 0,
//        beg, // индекс первой буквы слова
//        dl_str, // длина текущей строки
//        dl_word; // длина очередного выделенного слова
//    system("cls");
//    i = 0;
//    setlocale(0, "");
//    // Цикл ввода строк символов, пока не конец потока ввода (CTRL+Z) и кол-во строк не > M
//    while ((gets_s(wstr) != NULL) && (i < M)) //считываем очередную стоку в рабочую строку
//    {
//        //выделяем динамически память для хранения введенной строки
//        //адрес выделенной памяти сохраняем в массиве указателей на строки
//        //размер выделенной памяти на 1 больше длины рабочей строки (для '\0')
//        dl_wstr = strlen(wstr) + 1;
//        s[i] = new char[dl_wstr];
//        //копируем содержимое рабочей строки в динамически выделенный участок памяти
//        strcpy_s(s[i], dl_wstr, wstr);
//        i++;
//    }
//    kol_str = i;
//    e = 0, f = 0;
//    bool flag = 0;
//    words[e] = new char[80];
//    for (i = 0; i < kol_str; i++) {
//        dl_str = strlen(s[i]);
//        for (j = 0; j <= dl_str; j++) {
//
//            if ((*(s[i] + j) == ' ' || *(s[i] + j) == '\0' || *(s[i] + j) == ',') && flag) {
//                e++;
//                f = 0;
//                words[e] = new char[80];
//                flag = false;
//            }
//
//            else {
//                words[e][f] = *(s[i] + j);
//                f++;
//                flag = true;
//
//            }
//
//        }
//    }
//
//    int last_e = e;
//    for (int i = 0; i < last_e; ++i) {
//        std::cout << words[i] << "\n";
//
//
//    }
//
//
//
//    delete[] s;
//
//    for (e = 0; e < last_e; e++) {
//        delete[] words[e];
//    }
//
//    delete[] words;
//
//
//
//}
 

    //for (i = 0; i < kol_str; i++) // перебираем все введенные строки
    //{
    //    dl_str = strlen(s[i]); // определяем длину текущей строки
    //    for (j = 0; j <= dl_str; j++) // движемся по строке
    //        if (*(s[i] + j) == ' ' || *(s[i] + j) == '\0' || *(s[i] + j) == ',')
    //            // если встретили символ-разделитель
    //        {
    //            if (inword == 1) // и этот символ первый после слова
    //            {
    //                dl_word = j - beg; // определяем длину текущего слова
    //                if (dl_word % 2) // если длина нечетная, то
    //                    // удаляем из слова средний символ, для чего сдвигаем все символы строки на одну позицию                        влево
    //                    // после середины слова и до конца строки (включая '\0')
    //                {
    //                for (j1 = beg + dl_word / 2; j1 < dl_str; j1++)
    //                *(s[i] + j1) = *(s[i] + j1 + 1);
    //                dl_str = dl_str - 1; // уменьшаем длину строки и
    //                j = j - 1; // индекс текущего символа в строке
    //                }
    //                inword = 0; // теперь находимся вне слова
    //            }
    //        }
    //        else // если не разделитель
    //            if (inword == 0) // и находимся вне слова,
    //            {
    //                inword = 1; // то встретили новое слово
    //                beg = j; // запоминаем индекс первого символа в                    слове
    //            }
    //}
    //// Выводим на экран преобразованный текст
    //printf("\nРезультат\n");
    //for (i = 0; i < kol_str; i++)
    //    puts(s[i]);
    //_getch();




////выделяем динамически память для хранения введенной строки
////адрес выделенной памяти сохраняем в массиве указателей на строки
////размер выделенной памяти на 1 больше длины рабочей строки (для '\0')
//dl_wstr = strlen(wstr) + 1;
//s[i] = new char[dl_wstr];
////копируем содержимое рабочей строки в динамически выделенный участок памяти
//strcpy_s(s[i], dl_wstr, wstr);
//i++;
//}
//kol_str = i;
//for (i = 0; i < kol_str; i++) // перебираем все введенные строки
//{
//dl_str = strlen(s[i]); // определяем длину текущей строки
//for (j = 0; j <= dl_str; j++) // движемся по строке
//if (*(s[i] + j) == ' ' || *(s[i] + j) == '\0' || *(s[i] + j) == ',')
//// если встретили символ-разделитель
//{
//if (inword == 1) // и этот символ первый после слова
//{
//dl_word = j - beg; // определяем длину текущего слова
//if (dl_word % 2) // если длина нечетная, то
//// удаляем из слова средний символ, для чего сдвигаем все символы строки на одну позицию
//влево
//// после середины слова и до конца строки (включая '\0')
//{
//for (j1 = beg + dl_word / 2; j1 < dl_str; j1++)
//*(s[i] + j1) = *(s[i] + j1 + 1);
//dl_str = dl_str - 1; // уменьшаем длину строки и
//j = j - 1; // индекс текущего символа в строке
//}
//inword = 0; // теперь находимся вне слова
//}
//}
//
//
//
//
// const int M = 10;
//    char** s, wstr[80];
//    int i,
//        j,
//        len_wstr,
//        count_str,
//        words_count,
//        flag,
//        k,
//        n;
//
//
//    system("cls");
//    i = 0;
//    j = 0;
//    k = 0;
//    n = 0;
//
//    setlocale(0, "");
//    s = new char* [10 * 40];
//    s[0] = new char[80];
//    while ((gets_s(wstr) != NULL) && (i < M))
//    {
//        len_wstr = strlen(wstr) + 1;
//
//        while (wstr[j] != '\0' || wstr[j] != '\n') {
//
//            if (wstr[j] != ' ' && wstr[j] != '.' && wstr[j] != ',') {
//
//                s[k][n] = wstr[j];
//                n++;
//                flag = 0;
//            }
//            else if (flag != 1) {
//                n = 0;
//                k++;
//                flag = 1;
//                s[k] = new char[80];
//            }
//            j++;
//        }
//
//
//        /*s[i] = new char* [len_wstr];
//        strcpy_s(*s[i], len_wstr, wstr);
//        for () {
//
//        }
//        i++;*/
//    }
//
//
//
//    words_count = k;
//    k = 0;
//
//
//    /*for (i = 0; i < words_count; i++) {
//        for (j = 0; j + 1 < words_count - i; j++) {
//            if (sizeof(s[i]) ) {
//                i;
//            }
//        }
//
//    }*/
//
//
//
//
//    std::cout << std::endl << (sizeof(s[i]));









    /*count_str = i;
    char* bag_of_words;


    for (i = 0; i < count_str; i++) {
        len_wstr = strlen(s[i]);


        for (j = 0; j <= len_wstr; j++) {
            if

        }
    }

}*/




// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
